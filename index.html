<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The One True Idler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
            color: #ffd700;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        .upgrades-section {
            margin-top: 30px;
        }
        
        .upgrades-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .upgrade-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .upgrade-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .upgrade-name {
            font-size: 1.2em;
            font-weight: bold;
        }
        
        .upgrade-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
        }
        
        .upgrade-description {
            margin-bottom: 15px;
            opacity: 0.9;
            font-size: 0.9em;
        }
        
        .upgrade-button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }
        
        .upgrade-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .upgrade-button:disabled {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
        }
        
        .offline-notification {
            background: rgba(76, 175, 80, 0.9);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.1em;
            animation: slideIn 0.5s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .reset-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background: rgba(244, 67, 54, 0.8);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        .reset-button:hover {
            background: rgba(244, 67, 54, 1);
        }
        
        .privacy-notice {
            background: rgba(33, 150, 243, 0.1);
            border: 1px solid rgba(33, 150, 243, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.85em;
            opacity: 0.9;
        }
        
        .error-notification {
            background: rgba(244, 67, 54, 0.9);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🛌 The One True Idler</h1>
		
		 <div class="game mechanic">
            Welcome to the One True Idler Game -- where progression only happens while the game is closed. Make your purchases and GTFO!
        </div>
        
        <div class="privacy-notice">
            🔒 <strong>Privacy:</strong> This game stores your progress locally in your browser only. No data is sent to servers or third parties. 
            You can reset your progress anytime using the reset button below.
        </div>
        
        <div id="errorNotification" class="error-notification" style="display: none;"></div>
        <div id="offlineNotification" class="offline-notification" style="display: none;"></div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value" id="coins">0</div>
                <div class="stat-label">Coins</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="coinsPerSecond">0</div>
                <div class="stat-label">Coins/Second</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalEarned">0</div>
                <div class="stat-label">Total Earned</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="offlineTime">0h 0m</div>
                <div class="stat-label">Last Offline</div>
            </div>
        </div>
        
        <div class="upgrades-section">
            <h2>😴 Upgrades</h2>
            <div class="upgrades-grid" id="upgradesContainer">
                <!-- Upgrades will be populated by JavaScript -->
            </div>
        </div>
    </div>
    
    <button class="reset-button" onclick="resetGame()">Reset Game</button>
    
    <script>
        // Security and validation constants
        const MAX_SAFE_COINS = 1e15; // 1 quadrillion coin limit
        const MAX_SAFE_UPGRADE_COUNT = 10000; // Maximum upgrades per type
        const MAX_OFFLINE_HOURS = 168; // 1 week maximum offline time
        
        // Game state
        let gameState = {
            coins: 50, // Start with 50 coins so player can buy first worker
            totalEarned: 0,
            coinsPerSecond: 0,
            lastSaveTime: Date.now(),
            version: "1.0", // For future save compatibility
            upgrades: {
                worker: { count: 0, baseCost: 10, baseProduction: 1 },
                machine: { count: 0, baseCost: 100, baseProduction: 8 },
                factory: { count: 0, baseCost: 1000, baseProduction: 50 },
                corporation: { count: 0, baseCost: 10000, baseProduction: 300 },
                megaCorp: { count: 0, baseCost: 100000, baseProduction: 2000 }
            }
        };
        
        // Validate and sanitize game state
        function validateGameState(state) {
            const validated = { ...state };
            
            // Validate numeric values
            validated.coins = Math.max(0, Math.min(validated.coins || 0, MAX_SAFE_COINS));
            validated.totalEarned = Math.max(0, Math.min(validated.totalEarned || 0, MAX_SAFE_COINS));
            validated.coinsPerSecond = Math.max(0, validated.coinsPerSecond || 0);
            validated.lastSaveTime = validated.lastSaveTime || Date.now();
            
            // Validate upgrades
            if (validated.upgrades) {
                for (const [key, upgrade] of Object.entries(validated.upgrades)) {
                    if (gameState.upgrades[key] && upgrade) {
                        validated.upgrades[key].count = Math.max(0, Math.min(
                            Math.floor(upgrade.count || 0), 
                            MAX_SAFE_UPGRADE_COUNT
                        ));
                    }
                }
            }
            
            // Validate time (prevent future dates)
            const currentTime = Date.now();
            if (validated.lastSaveTime > currentTime) {
                validated.lastSaveTime = currentTime;
            }
            
            return validated;
        }
        
        // Generate simple checksum for save integrity
        function generateChecksum(state) {
            const str = JSON.stringify({
                coins: Math.floor(state.coins),
                totalEarned: Math.floor(state.totalEarned),
                upgrades: state.upgrades
            });
            return btoa(str).slice(-8);
        }
        
        // Check if localStorage is available
        function isLocalStorageAvailable() {
            try {
                const test = '__localStorage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
            } catch (e) {
                return false;
            }
        }
        
        // Show error notification
        function showErrorNotification(message) {
            const notification = document.getElementById('errorNotification');
            notification.innerHTML = `⚠️ ${message}`;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 8000);
        }
        const upgradeDefinitions = {
            worker: {
                name: "👨‍🔬 Sleep Study Subject",
                description: "They heard about the study from a notice on the Student Union bulletin board. Unfortunately they'll never be heard from again."
            },
            machine: {
                name: "👹 Sleep Demon",
                description: "Summoning these is probably a bad idea, but they sure know how to harvest some precious life force from the slumbering masses"
            },
            factory: {
                name: "🏭 Mattress Factory",
                description: "Definitely not a money laundering front. These mattresses will give you the best sleep of your life -- perpetual."
            },
            corporation: {
                name: "🍗 Tryptophan Distribution Center",
                description: "'It's not just for turkey anymore!'"
            },
            megaCorp: {
                name: "🗿 The One True Idol",
                description: "A monument to the world's newest ideology -- One-With-Nothingness."
            }
        };
        
        // Load game state from localStorage
        function loadGame() {
            // Check if localStorage is available
            if (!isLocalStorageAvailable()) {
                showErrorNotification('Browser storage not available. Progress will not be saved.');
                return;
            }
            
            const saved = localStorage.getItem('idleGameSave');
            const checksum = localStorage.getItem('idleGameChecksum');
            console.log('Loading game...', saved ? 'Save found' : 'No save found');
            
            if (saved) {
                try {
                    const savedState = JSON.parse(saved);
                    console.log('Saved state:', savedState);
                    
                    // Verify checksum if available
                    if (checksum) {
                        const expectedChecksum = generateChecksum(savedState);
                        if (checksum !== expectedChecksum) {
                            console.warn('Save data checksum mismatch - possible tampering detected');
                            showErrorNotification('Save data appears corrupted. Using safe defaults.');
                        }
                    }
                    
                    // Validate and sanitize the saved state
                    const validatedState = validateGameState(savedState);
                    
                    // Merge validated state with defaults
                    gameState.coins = validatedState.coins;
                    gameState.totalEarned = validatedState.totalEarned;
                    gameState.coinsPerSecond = validatedState.coinsPerSecond;
                    gameState.lastSaveTime = validatedState.lastSaveTime;
                    gameState.version = validatedState.version || gameState.version;
                    
                    // Load upgrades
                    if (validatedState.upgrades) {
                        for (const [key, upgrade] of Object.entries(validatedState.upgrades)) {
                            if (gameState.upgrades[key]) {
                                gameState.upgrades[key].count = upgrade.count || 0;
                            }
                        }
                    }
                    
                    // Calculate offline progress
                    const currentTime = Date.now();
                    const offlineTime = currentTime - gameState.lastSaveTime;
                    const offlineHours = offlineTime / (1000 * 60 * 60);
                    
                    console.log('Offline time:', offlineTime, 'ms (', offlineHours, 'hours)');
                    
                    // Cap offline time for security
                    const cappedOfflineHours = Math.min(offlineHours, MAX_OFFLINE_HOURS);
                    
                    if (offlineTime > 3000) { // Show notification if offline for more than 3 seconds
                        updateCoinsPerSecond(); // Make sure CPS is calculated first
                        const offlineCoins = calculateOfflineGains(cappedOfflineHours);
                        console.log('Offline coins calculated:', offlineCoins);
                        
                        if (offlineCoins > 0) {
                            showOfflineNotification(offlineTime, offlineCoins);
                            gameState.coins = Math.min(gameState.coins + offlineCoins, MAX_SAFE_COINS);
                            gameState.totalEarned = Math.min(gameState.totalEarned + offlineCoins, MAX_SAFE_COINS);
                        }
                    }
                    
                    gameState.lastSaveTime = currentTime;
                } catch (e) {
                    console.error('Failed to load save:', e);
                    showErrorNotification('Failed to load save data. Starting fresh.');
                }
            } else {
                console.log('New game started with', gameState.coins, 'coins');
            }
        }
        
        // Save game state to localStorage
        function saveGame() {
            if (!isLocalStorageAvailable()) {
                console.warn('Cannot save: localStorage not available');
                return;
            }
            
            try {
                gameState.lastSaveTime = Date.now();
                const saveData = JSON.stringify(gameState);
                const checksum = generateChecksum(gameState);
                
                localStorage.setItem('idleGameSave', saveData);
                localStorage.setItem('idleGameChecksum', checksum);
                console.log('Game saved successfully');
            } catch (e) {
                console.error('Failed to save game:', e);
                showErrorNotification('Failed to save progress. Check if you have enough storage space.');
            }
        }
        
        // Calculate offline gains
        function calculateOfflineGains(hours) {
            updateCoinsPerSecond();
            const maxOfflineHours = Math.min(hours, MAX_OFFLINE_HOURS);
            const coinsEarned = Math.floor(gameState.coinsPerSecond * maxOfflineHours * 3600);
            return Math.min(coinsEarned, MAX_SAFE_COINS - gameState.coins);
        }
        
        // Show offline notification
        function showOfflineNotification(timeAway, coinsEarned) {
            const hours = Math.floor(timeAway / (1000 * 60 * 60));
            const minutes = Math.floor((timeAway % (1000 * 60 * 60)) / (1000 * 60));
            
            const notification = document.getElementById('offlineNotification');
            notification.innerHTML = `
                Welcome back! You were away for ${hours}h ${minutes}m<br>
                You earned <strong>${formatNumber(coinsEarned)}</strong> coins while offline! 💰
            `;
            notification.style.display = 'block';
            
            // Hide notification after 5 seconds
            setTimeout(() => {
                notification.style.display = 'none';
            }, 5000);
        }
        
        // Calculate current coins per second
        function updateCoinsPerSecond() {
            let cps = 0;
            for (const [key, upgrade] of Object.entries(gameState.upgrades)) {
                cps += upgrade.count * upgrade.baseProduction;
            }
            gameState.coinsPerSecond = cps;
        }
        
        // Calculate upgrade cost
        function getUpgradeCost(upgradeKey) {
            const upgrade = gameState.upgrades[upgradeKey];
            return Math.floor(upgrade.baseCost * Math.pow(1.15, upgrade.count));
        }
        
        // Buy upgrade
        function buyUpgrade(upgradeKey) {
            if (!gameState.upgrades[upgradeKey]) return;
            
            const cost = getUpgradeCost(upgradeKey);
            if (gameState.coins >= cost && gameState.upgrades[upgradeKey].count < MAX_SAFE_UPGRADE_COUNT) {
                gameState.coins -= cost;
                gameState.upgrades[upgradeKey].count++;
                updateCoinsPerSecond();
                updateDisplay();
                saveGame();
            }
        }
        
        // Format large numbers
        function formatNumber(num) {
            if (num < 1000) return Math.floor(num).toString();
            if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
            if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
            if (num < 1000000000000) return (num / 1000000000).toFixed(1) + 'B';
            return (num / 1000000000000).toFixed(1) + 'T';
        }
        
        // Format time
        function formatTime(ms) {
            const hours = Math.floor(ms / (1000 * 60 * 60));
            const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
            return `${hours}h ${minutes}m`;
        }
        
        // Update display
        function updateDisplay() {
            document.getElementById('coins').textContent = formatNumber(gameState.coins);
            document.getElementById('coinsPerSecond').textContent = formatNumber(gameState.coinsPerSecond);
            document.getElementById('totalEarned').textContent = formatNumber(gameState.totalEarned);
            
            const lastOffline = Date.now() - gameState.lastSaveTime;
            document.getElementById('offlineTime').textContent = formatTime(lastOffline);
            
            // Update upgrade buttons
            for (const [key, def] of Object.entries(upgradeDefinitions)) {
                const cost = getUpgradeCost(key);
                const button = document.getElementById(`upgrade-${key}`);
                if (button) {
                    const canAfford = gameState.coins >= cost;
                    const atLimit = gameState.upgrades[key].count >= MAX_SAFE_UPGRADE_COUNT;
                    
                    button.disabled = !canAfford || atLimit;
                    button.textContent = atLimit ? 'Max Level' : `Buy - ${formatNumber(cost)} coins`;
                }
            }
        }
        
        // Create upgrade UI
        function createUpgradeUI() {
            const container = document.getElementById('upgradesContainer');
            
            for (const [key, def] of Object.entries(upgradeDefinitions)) {
                const upgradeCard = document.createElement('div');
                upgradeCard.className = 'upgrade-card';
                
                const upgrade = gameState.upgrades[key];
                const production = upgrade.baseProduction;
                
                upgradeCard.innerHTML = `
                    <div class="upgrade-header">
                        <div class="upgrade-name">${def.name}</div>
                        <div class="upgrade-count">${upgrade.count}</div>
                    </div>
                    <div class="upgrade-description">
                        ${def.description}<br>
                        <strong>+${formatNumber(production)} coins/second</strong>
                    </div>
                    <button class="upgrade-button" id="upgrade-${key}" onclick="buyUpgrade('${key}')">
                        Loading...
                    </button>
                `;
                
                container.appendChild(upgradeCard);
            }
        }
        
        // Reset game
        function resetGame() {
            if (confirm('Are you sure you want to reset your progress? This cannot be undone!')) {
                try {
                    localStorage.removeItem('idleGameSave');
                    localStorage.removeItem('idleGameChecksum');
                    location.reload();
                } catch (e) {
                    console.error('Failed to reset game:', e);
                    showErrorNotification('Failed to reset game data. Try clearing your browser data manually.');
                }
            }
        }
        
        // Save game when page is about to close
        window.addEventListener('beforeunload', saveGame);
        
        // Auto-save every 10 seconds
        setInterval(saveGame, 10000);
        
        // Main game loop (only updates display, no actual progression)
        function gameLoop() {
            updateDisplay();
        }
        
        // Initialize game
        loadGame();
        updateCoinsPerSecond();
        createUpgradeUI();
        updateDisplay();
        
        // Start game loop
        setInterval(gameLoop, 1000);
        
        console.log('🎮 Idle Factory Empire loaded!');
        console.log('💡 Close the browser and come back later to see offline progress!');
    </script>
</body>
</html>